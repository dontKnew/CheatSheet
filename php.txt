PHP OOP  Concept 
1. class and objects
=> $this : this keyword refere to current and this available only inside of method.
<?php
class Fruit {
  // Properties
  public $name;
  public $color;

  // Methods
  function set_name($name) {
    $this->name = $name;
  }
  function get_name() {
    return $this->name;
  }
}

$apple = new Fruit();
$banana = new Fruit();
$apple->set_name('Apple');
$banana->set_name('Banana');

echo $apple->get_name();
echo "<br>";
echo $banana->get_name();
?>

=> we can change our property value by two method :
	i). Inside the class (by adding a set_name() method and use $this):
<?php
class Fruit {
//properties
  public $name;

//method
  function set_name($name) {
    $this->name = $name;
  }
}
//objects
$apple = new Fruit();
$apple->set_name("Apple");

echo $apple->name;
?>

	ii). Outside the class (by directly changing the property value):
<?php
class Fruit {
  public $name;
}
// object
$apple = new Fruit();
$apple->name = "Apple";

echo $apple->name;
?>
Note: In a class, variables are called properties and functions are called methods!	
=> var_dump($apple instanceof Fruit);// instanct of : check apple class is belong to specific class

2. __construct 
=> construct function start with double underscore line like that : __construct
=> construct function automatically called 
=> construct like an parameter of function
=> we can reduce amount code by using construct function lets take an example, 
In first exampl function we used set_name()  function method, now construct take place instead of set_name() method
ample
<?php
class Fruit {
  public $name;
  public $color;

  function __construct($name, $color) {
    $this->name = $name;
    $this->color = $color;
  }
  function get_name() {
    return $this->name;
  }
  function get_color() {
    return $this->color;
  }
}

$apple = new Fruit("Apple", "red");
echo $apple->get_name();
echo "<br>";
echo $apple->get_color();
?>

3. __destructor
=> destructor function start with double underscore line like that : __destructor
=> destructor function will called end the of php script.
=> we can reduce amount code by using destructor function lets take an example, 
In above said construct function we used get_name() method in class for print our data,  now destructor take place instead of get_name() and get_color() method for print data
<?php
class Fruit {
  public $name;
  public $color;

  function __construct($name) {
    $this->name = $name;
     $this-color = $color
  }
  function __destruct() {
    echo "The fruit is {$this->name} and the color is {$this->color}.";
  }
}

$apple = new Fruit("Apple", "red");
?>

4. Access Modifiers
=> public : this is default and the property and method  can be accessed from everywhere.
=> protected : property and method can be accessed within class and by class derived from that class
=> private : property and method can be accessed within class 
Example : 
<?php
class Fruit {
  public $name;
  public $color;
  public $weight;

  function set_name($n) {  // a public function (default)
    $this->name = $n;
  }
  protected function set_color($n) { // a protected function
    $this->color = $n;
  }
  private function set_weight($n) { // a private function
    $this->weight = $n;
  }
}

$mango = new Fruit();
$mango->set_name('Mango'); // OK
$mango->set_color('Yellow'); // FATAL ERROR
$mango->set_weight('300'); // FATAL ERROR
?>

5. Inheritance : When a class derives from another class and An Class all method and properties also included protected properties transfer to other class using extends keywords.
= inheritance can extension only one times from parent class
=> inheritance properties and method use own metod and also use parent class properitis and method.
class Fruit {
  public $name;
  public $color;
  public function __construct($name, $color) {
    $this->name = $name;
    $this->color = $color;
  }
  public function intro() {
    echo "The fruit is {$this->name} and the color is {$this->color}.";
  }
}

// Strawberry is inherited from Fruit
class Strawberry extends Fruit {
  public function message() {
    echo "Am I a fruit or a berry? ";
  }
}
$strawberry = new Strawberry("Strawberry", "red");
$strawberry->message();
$strawberry->intro();
?>

=> Inherited methods can be overridden by redefining the methods (use the same name) in the child class.
Example : <?php
class Fruit {
  public $name;
  public $color;
  public function __construct($name, $color) {
    $this->name = $name;
    $this->color = $color;
  }
  public function intro() {
    echo "The fruit is {$this->name} and the color is {$this->color}.";
  }
}

class Strawberry extends Fruit {
  public $weight;
  public function __construct($name, $color, $weight) {
    $this->name = $name;
    $this->color = $color;
    $this->weight = $weight;
  }
  public function intro() {
    echo "The fruit is {$this->name}, the color is {$this->color}, and the weight is {$this->weight} gram.";
  }
}

$strawberry = new Strawberry("Strawberry", "red", 50);
$strawberry->intro();
?>
// overitted in intro method in class object

=> whenver you used final keyword, thats could not be inheritance and prevent method overiding
example : 
final class Fruit {
  // some code
}

// will result in error
class Strawberry extends Fruit {
  // some code
}

6. constant : like that an variabale, 
=>once declared, cant be change value of this variable
=> recommend variable should be in uppercase letter.
=> it can be call the variable outside and inside of variable
outside example :  className::variableName
<?php
class Goodbye {
  const LEAVING_MESSAGE = "Thank you for visiting W3Schools.com!";
}

echo Goodbye::LEAVING_MESSAGE;
?>

Inside example self::VariableName
<?php

class Goodbye {

  const LEAVING_MESSAGE = "Thank you for visiting W3Schools.com!";

  public function byebye() {

    echo self::LEAVING_MESSAGE;

  }

}

$goodbye = new Goodbye();

$goodbye->byebye();

?>

7. Abstruct class
=> Abstract class always use inheritance mean extends keyword 
=>If dont want to create object then u can make abstruct class
=>make an abstruct class with abstruct keyword
=> we can not define our method in abstruct class like that 
abstruct  class Test{
  //  This wrong
   abstruct function getName() {
    return "Rahul";
// correct 
abstruct function getNams();
}
=> in abstruct class, abstruct method name must be same in extends class methid
=> you can not declared abstruct method without abstruct class, but abstruct class can be declare without abstruct method with normal method.
=> abstruct class use for only information 

An complete abstruct class example :
<?php
abstract class ParentClass {
  // Abstract method with an argument
  abstract protected function prefixName($name);
} 

class ChildClass extends ParentClass {
  // The child class may define optional arguments that are not in the parent's abstract method
  public function prefixName($name, $separator = ".", $greet = "Dear") {
    if ($name == "John Doe") {
      $prefix = "Mr";
    } elseif ($name == "Jane Doe") {
      $prefix = "Mrs";
    } else {
      $prefix = "";
    }
    return "{$greet} {$prefix}{$separator} {$name}";
  }
} 

$class = new ChildClass;
echo $class->prefixName("John Doe");
echo "<br>";
echo $class->prefixName("Jane Doe");
?>


8. Interface class by implements 
=> interface like abstruct methid
=> all method are public
=> instance variable does not have
=> we could not use private and protected
=> we could not create object of interface
=> in interfae class method should be define in implements class 
=>cannot have properties 
=>must be define all interface method  in implements class
=> method name should be equal implements class method name while define
=> one interface class can be implement in multiple implements  class
An example of interface
<?php
// Interface definition
interface Animal {
  public function makeSound();
} 

// Class definitions
class Cat implements Animal {
  public function makeSound() {
    echo " Meow ";
  }
} 

class Dog implements Animal {
  public function makeSound() {
    echo " Bark ";
  }
} 

class Mouse implements Animal {
  public function makeSound() {
    echo " Squeak ";
  }
} 

// Create a list of animals
$cat = new Cat();
$dog = new Dog();
$mouse = new Mouse();
$animals = array($cat, $dog, $mouse); 

// Tell the animals to make a sound
foreach($animals as $animal) {
  $animal->makeSound();
}
?> 

9. Traits : traits class declared method can be used in multiple class
=> can be used abstruct method 
=> can be use any access modifier ( check notes for access modifier)
=> reduce the code duplication 
An example, :
<?php
trait message1 {
  public function msg1() {
    echo "OOP is fun! ";
  }
} 

trait message2 {
  public function msg2() {
    echo "OOP reduces code duplication!";
  }
} 

class Welcome {
  use message1;
} 

class Welcome2 {
  use message1, message2;
} 

$obj = new Welcome();
$obj->msg1();
echo "<br>"; 

$obj2 = new Welcome2();
$obj2->msg1();
$obj2->msg2();
?> 

10. Static method : call the function from anywhere outside class and inside class
Outside example : 
<?php
class greeting {
  public static function welcome() {
    echo "Hello World!";
  }
}
echo greeting::welcome();
?>
Inside example :
<?php
class greeting {
  public static function welcome() {
    echo "Hello World!";
  } 

  public function __construct() {
    self::welcome();
  }
}
new greeting();
?> 
=> static method can call outside extends or implements  class with outside method
=> call the static method from child class to parent class With using outside class example : 
<?php
class domain {
  protected static function getWebsiteName() {
    return "W3Schools.com";
  }
} 

class domainW3 extends domain {
  public $websiteName;
  public function __construct() {
    $this->websiteName = parent::getWebsiteName();
  }
} 

$domainW3 = new domainW3;
echo $domainW3 -> websiteName;
?> 

10.1 static properties; its call the without class and directly from anywhere outside and inside like constant properties(once declared properties) above said.
=> But static properties can be re declared
=> it can also be  access from child to parent class like above said last example of static method



11. namespace : can be allowed to use same name more one class.
=> namspace decalred at the top of php file
Like that namespace fileName
= can be assign  namespace HTML to other name  with use keyword
use namespaceFileName as newNameSpace File 

=> also alias class name  with use keyword
Example : use HTML\ClassName as shortNewClassName 

Example :
1. You  two file and therein file class name is same.
2. Now use the those same class two file with using namespace in single single file
1. first.php
namspace  p{ 
class Product {
__construct(){
echo " I am product page of class product";
$obj = new \p\Product(); // use class under an class with same name class
  }
}
} 

2. Second. php
namspace  test; 
class Product {
__construct(){
echo " I am  test product page  of class product";
}
}
3. Third file 

$obj = new p\Product();
$obj = new t\Product()
=> if u run without name space class it will given error: could be not used already define class again.
= u can use also same class in class with using name space syntax : $obj = new \p\Product(); 

namespacs obj\v1\command; u can use like this namespace


12. dia("error") => no next code run
12.1 __class__ , when use this magic  varibale this get the current class name under current class  method or properties. 

13. If u used OOP , use mysqli OOP, or PDO
14. Use curly brace for declare variable with text echo



15. Magic method 
=> all magic method use with double underscore
=> methods are called automatically  for some or some other function
= __set for property_exits, _get for array_property_exts, _call for method
=> some magic method use for the set value or access value from class private methods
=> magic method always use public acces modifier 



15.2  __autoload 
=> we are using required or included function for add our file to current file , spouse we have 100 require/include file how can i do it ? 
So we are using autoload function
function __autoload ($class) {
  required 'filePath/' .$class. ' .php
}
$obj = new ClassName(); // no need to include file which have class, __autoload directly autoload whenver u used any object in current file with autoload function
15.2  __get
=> instead of get error of class function , we can define custom error text.
=> if class  or object have an error it will auto called and display our custome error text.
Example 1. 
We can knew access modifier properties have private or protected method can not be call out of class .
class fruits(){
private $name = "Krishma";
function hello(){
echo "hello $this->$name";
}
function __get(){
echo "Private properties could not access or non existing";
}
}
$obj = new fruits();
$obj->hello(); // 
$obj->hello1(); // 

=> if u call undefined properties or method, it will also called get magic method function 
=> we received an custom __get function error instead of fatel error.
=> we can also access private properties by this get magic method function by under function $this->name; 

15.3 __set Method : like that get method
=> but get access value of private propertie which is define in class
=we can set an private properties value using set method
=> if you are not use set method and set the value of private properties, it will give u an fatal error., now can also define custom error instead of fatal error like get magic method. 

Exmaple : 

class fruits(){
private $name; 

function hello(){
echo "hello $this->$name";
}
function __get(){
echo "Private properties could not access or non existing";
}
function _set() {
echo " private properties could not be set value";
}
}
$obj = new fruits();
$obj->name = "Sajid"; // give set method echo text; 

Example 2. Lets check how can you assign an value of class priavte properties.
class fruits(){
private $name; 

function hello(){ // property value has been define, now call print defined Property.
echo "hello $this->$name";
} 
function __get(){
echo "Private properties could not access or non existing";
}
function _set($property, $value) { // first parameter properties name, second paramter is value 
if(property_exits($this, $property) {
     $this->name = $value;
} else {
    echo "Property unrefined";
}
}
}
$obj = new fruits();
$obj->name = "Sajid"; // if Property name is exist then set value else give u an custom error which is defined in set method function.
$obj->hello(); 

15.3 __call  
=> like that set method , but they only working on method properties.
=> lets set priavte method value from outside of class using __call method
Exmaple 1. Like that get  magic method example 1
Example 2. 
class fruits(){
private $firstname;
private $lastname; 

function hello(){ // property value has been define, now call print defined Property.
echo "hello {$this->firstname} {$this->lastname}";
} 
function __get(){
echo "Private properties could not access or non existing";
}
function setName($firstnams, $lastname) {
  $this->$firstname = $firstname
$this->$firstname = $firstname
} // value set in private properties by using call magic method 

function _call($method $args) { // first parameter  method namd, second paramter is arguments mean value which is use later  under call_user_func_array();
if(method_exits($this, $method) {
     call_user_func_array([$this, $method], $args); 
} else {
    echo "Property unrefined or non existing property.";
}
}
}
$obj = new fruits();
$obj->name = "Sajid"; // if Property name is exist then set value else give u an custom error which is defined in set method function.
$obj->hello(); 

15.4 __callStatic method : this method use for only static method for call the private method and set the value of private method.
=> if static method does not defined give u custom __callStatic method function error like __get and __set and call__ magic method 

Example 1. Like that above said __get magic example  1. 

Example 2 .
class greeting {
  private static function welcome($name) {
    echo "Hello World! {$this->nams}";
  }
public static function __callStatic($method, $args) {
if(method_exists(__class__, $method,) /* __class__ is returnt the current class name*/
user_func_array([ __class__, $method],$args) // value has been defined in $name static private function parameters
}else {
echo "undefined method {$method}";
}
}
greeting::welcome();







